#include <iostream>
#include <vector>

using namespace std;

int main(){
    //Список смежности

    // В этом случае каждой вершине x сопоставляется
    //список смежности, включающий вершины, соединенные с x ребром.
    //Константа N выбрана так, чтобы в массиве поместились все списки смежности.
    int N = 5;
    vector<int> adj[N];
    adj[1].push_back(2);
    adj[2].push_back(3);
    adj[2].push_back(4);
    adj[3].push_back(4);
    adj[4].push_back(1);
    //Неориентированные графы можно хранить аналогично, только каждое
    //ребро нужно учитывать в двух списках смежности (для обоих направлений)

    //Для взвешенных графов структуру следует дополнить:
    vector<pair<int, int>> adj2[N];
    //В этом случае список смежности вершины a содержит пару (b,w), если
    //существует ребро с весом w, направленное от a к b.
    adj2[1].push_back({2, 5});
    adj2[2].push_back({3, 7});
    adj2[2].push_back({4, 6});
    adj2[3].push_back({4, 5});
    adj2[4].push_back({1, 2});

    //Следующий цикл обходит все вершины, в которые можно попасть из вершины 1:
//    for(auto x: adj[1]){
//        //Обработать вершниу x;
//    }



    //Матрица смежности

    //Матрица смежности показывает, какие ребра есть в графе. С ее помощью можно эффективно проверить, существует
    // ли ребро между двумя вершинами

    int adj3[N][N];
    adj3[1][0] = 0, adj3[1][1] = 1, adj3[1][2] = 0, adj3[1][3] = 0;
    adj3[2][0] = 0, adj3[2][1] = 1, adj3[2][2] = 1, adj3[2][3] = 1;
    adj3[3][0] = 0, adj3[3][1] = 0, adj3[3][2] = 0, adj3[3][3] = 1;
    adj3[4][0] = 1, adj3[4][1] = 0, adj3[4][2] = 0, adj3[4][3] = 0;

    //Если граф взвешенный, то представление в виде матрицы смежности
    //можно обобщить: если две вершины соединены ребром, то в матрице хранится вес этого ребра.

    //Недостаток матрицы смежности заключается в том, что она содержит n^2
    //элементов, большая часть которых обычно равна 0.
    // Поэтому такое представление не годится для больших графов.



    //Список ребер

    //Список ребер содержит все ребра графа в некотором порядке.
    // Это представление удобно, если алгоритм обрабатывает все ребра и не требуется
    //находить ребра, начинающиеся в заданной вершине.

    vector<pair<int, int>> edges;

    //где наличие пары (a, b) означает, что существует ребро из вершины a в вершину b

    edges.push_back({1, 2});
    edges.push_back({2, 3});
    edges.push_back({2, 4});
    edges.push_back({3, 4});
    edges.push_back({4, 1});

    //Для взвешенных графов структуру можно обобщить:

    vector<tuple<int,int,int>> edges2;
    
    //Каждый элемент этого списка имеет вид (a,b,w), это означает,
    // что существует ребро с весом w, ведущее из вершины a в вершину b.

    edges2.push_back({1,2,5});
    edges2.push_back({2,3,7});
    edges2.push_back({2,4,6});
    edges2.push_back({3,4,5});
    edges2.push_back({4,1,2});

}