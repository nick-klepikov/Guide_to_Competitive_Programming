#include <iostream>

using namespace std;

//Система непересекающихся множеств (union-find structure) состоит из
//коллекции множеств. Поддерживаются две операции с временной сложностью O(log n): unite объединяет два
//множества, а find находит представителя множества, содержащего заданный элемент.

//В системе непересекающихся множеств в каждом множестве выбирается
//по одному представителю, и существует путь от любого элемента множества
//к его представителю.

//Два элемента принадлежат одному и тому же множеству тогда и только тогда, когда у
//них одинаковые представители.



const int n = 8;

int link[n+1], size[n+1];

int find(int x){
    while(x != link[x]) x = link[x];
    return x;
}

//Второй способ реализации, со сжатием путей
//после выполнения операции каждый элемент, находящийся на пути,
// указывает непосредственно на своего представителя.

//int find(int x){
//  if(x == link[x]) return x;
//  return link[x] = find(link[x]);
//
//  Однако сжатие путей нельзя использовать в некоторых приложениях
//  системы непересекающихся множеств
//}



//Функция same проверяет, принадлежат ли элементы a и b одному множеству.
// Это легко сделать, воспользовавшись функцией find:

bool same(int a, int b){
    return find(a) == find(b);
}

void unite(int a, int b){
    a = find(a);
    b = find(b);
    if(size[a] < size[b]) swap(a, b);
    size[a] += size[b];
    link[b] = a;
}

int main(){

    //Для каждого элемента в массиве link хранится следующий элемент пути или сам этот элемент,
    // если он является представителем,
    // а в массиве size для каждого представителя хранится размер соответствующего множества.

    //Вначале каждое множество состоит из одного элемента:

    for(int i = 1; i <= n; i++) link[i] = i;
    for(int i = 1; i <= n; i++) size[i] = 1;

}
