#include <iostream>

using namespace std;

int main(){
    //Эту задачу можно было бы легко решить методом перестановок за время O(n*n!), но если использовать подмножества,
    // то можно реализовать алгоритм с временной сложностью O(n*2^n)
    //x - макс. вес, n - кол-во людей
    int x = 12, n = 5, weight[] = {2, 3, 4, 5, 9};
    pair<int, int> best[1 << n];
    /*  Для каждого подмножества S будет храниться два значения:
     rides(S) и last(S), где rides(S) - минимальное число поездок для подмножества S, last(S) - минимальный вес
     последней группы в решении с минимальным числом поездок
    */
    best[0] = {0, 0};
    for(int s = 1; s < (1<<n); s++){//Перебор всех возможных подмножеств
        //начальное значение: необходимо n+1 поездок
        best[s] = {n+1, 0};
        for(int p = 0; p < n; p++){
            if(s&(1<<p)){ //Проверка на присутствие пассажира в подмножестве
                auto option = best[s^(1<<p)]; //значение подмножества, обработанного до текущего, включающего всех тех же пассажиров, кроме текущего
                if(option.second+weight[p] <= x){
                    //добавить p в существующую группу пассажиров
                    option.second += weight[p];
                } else {
                    //предусмотреть для p отдельную поездку
                    option.first++;
                    option.second = weight[p];
                }
                best[s] = min(best[s], option);
            }
        }
    }
    for(auto i: best) cout << i.first << ' ' << i.second << '\n';
}